function [features] = eogAnalysis(eog_data, sampling_rate)
    % 特徴量抽出
    features = extract_features(eog_data, sampling_rate);
    
    % 特徴量をベクトルに変換
    features_vector = features_to_vector(features);

    function features = extract_features(eog_data, sampling_rate)
        num_cells = numel(eog_data);

        % 特徴量を格納するための構造体配列を初期化
        features = struct('mean', cell(1, num_cells), 'std', cell(1, num_cells), ...
                          'max', cell(1, num_cells), 'min', cell(1, num_cells), ...
                          'range', cell(1, num_cells), 'gradient_mean', cell(1, num_cells), ...
                          'gradient_std', cell(1, num_cells), 'skewness', cell(1, num_cells), ...
                          'kurtosis', cell(1, num_cells), 'psd_delta', cell(1, num_cells), ...
                          'psd_theta', cell(1, num_cells), 'psd_alpha', cell(1, num_cells), ...
                          'psd_beta', cell(1, num_cells), 'zero_crossing_rate', cell(1, num_cells));

        for i = 1:num_cells
            current_data = eog_data{i};

            % 時間領域特徴
            features(i).mean = mean(current_data);
            features(i).std = std(current_data);
            features(i).max = max(current_data);
            features(i).min = min(current_data);
            features(i).range = features(i).max - features(i).min;

            % 勾配特徴
            gradient = diff(current_data);
            features(i).gradient_mean = mean(gradient);
            features(i).gradient_std = std(gradient);

            % 統計的特徴
            features(i).skewness = skewness(current_data);
            features(i).kurtosis = kurtosis(current_data);

            % 周波数領域特徴
            [psd, f] = pwelch(current_data, [], [], [], sampling_rate);
            features(i).psd_delta = sum(psd(f >= 0.5 & f < 4));
            features(i).psd_theta = sum(psd(f >= 4 & f < 8));
            features(i).psd_alpha = sum(psd(f >= 8 & f < 13));
            features(i).psd_beta = sum(psd(f >= 13 & f < 30));

            % ゼロ交差率
            zero_crossings = sum(diff(sign(current_data)) ~= 0);
            features(i).zero_crossing_rate = zero_crossings / length(current_data);
    end
end

    function feature_vector = features_to_vector(features)
        % 特徴量構造体をベクトルに変換
        feature_names = fieldnames(features);
        num_features = length(feature_names);
        num_samples = length(features);

        feature_vector = zeros(num_samples, num_features);

        for i = 1:num_samples
            for j = 1:num_features
                feature_value = features(i).(feature_names{j});
                if isnumeric(feature_value) && isscalar(feature_value)
                    feature_vector(i, j) = feature_value;
                elseif isnumeric(feature_value) && ~isscalar(feature_value)
                    % 複数のチャンネルがある場合は平均を取る
                    feature_vector(i, j) = mean(feature_value);
                else
                    feature_vector(i, j) = NaN;
                end
            end
        end
    end
end